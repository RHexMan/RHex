.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "RichGSL 3"
.TH RichGSL 3 "2019-03-22" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RichGSL \- A perl XS that interfaces with a static build of the part of the GSL that implements ODE solution.  This was done before by Joel Berger, with the more common dynamic linking.  A higher\-level perl interface is available in RUtils::RDiffEq, which is more completely documented.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use RichGSL qw (rc_ode_solver);
\& 
\& and call
\&        my $results = rc_ode_solver($eqn,$jac,$t0,$t1,$num_steps,$num_y,$y0Ref,$step_type,$h_init,$epsabs,$epsrel);
\&        
\&  The first argument is a pointer to the test function, and the second a pointer to a function that supplies the jacobian matrix that is required by some of the particular stepping routines, as indicated below.  The integration is run from t0 to t1 and results are reported at equal intervals whose length is determined by num_steps.  Num_y is the number of dependent variables, and y0Ref is a pointer to the initial values of the dependent variables.
\&
\&  The C\-code that calls the library is in the file rc_ode_solver.c in the XS project.  A full description of the GSL ODE library functions may be found at https://www.gnu.org/software/gsl/doc/html/ode\-initval.html.
.Ve
.PP
==head1 \s-1EXPORTED FUNCTIONS\s0
.SS "rc_ode_solver"
.IX Subsection "rc_ode_solver"
\fIthe differential equation system\fR
.IX Subsection "the differential equation system"
.PP
The differential equation system is defined in a code reference (in the example \f(CW$diffeq_code_ref\fR). This code reference (or anonymous subroutine) must have a specific construction:
.IP "\(bu" 4
The first argument will be time (or the independent parameter) and the rest will be the function values in the same order as the initial conditions. The returns in this case should be the values of the derivatives of the function values.
.Sp
If one or more of the returned values are not numbers (as determined by Scalar::Util \f(CW\*(C`looks_like_number\*(C'\fR), the solver will immediately return all calculations up until (and not including) this step, accompanied by a warning. This may be done intentionally to exit the solve routine earlier than the end time specified in the second argument.
.IP "\(bu" 4
Please note that as with other differential equation solvers, any higher order differential equations must be converted into systems of first order differential equations.
.PP
Optionally the system may be further described with a code reference which defines the Jacobian of the system (in the example \f(CW$jacobian_code_ref\fR). Again, this code reference has a specific construction. The arguments will be passed in exactly the same way as for the equations code reference (though it will not be called without arguments). The returns should be two array references.
.IP "\(bu" 4
The first is the Jacobian matrix formed as an array reference containing array references. It should be square where each dimension is equal to the number of differential equations. Each \*(L"row\*(R" contains the derivatives of the related differential equations with respect to each dependant parameter, respectively.
.Sp
.Vb 6
\& [
\&  [ d(dy[0]/dt)/d(y[0]), d(dy[0]/dt)/d(y[1]), ... ],
\&  [ d(dy[1]/dt)/d(y[0]), d(dy[1]/dt)/d(y[1]), ... ],
\&  ...
\&  [ ..., d(dy[n]/dt)/d(y[n])],
\& ]
.Ve
.IP "\(bu" 4
The second returned array reference contains the derivatives of the differential equations with respect to the independant parameter.
.Sp
.Vb 1
\& [ d(dy[0]/dt)/dt, ..., d(dy[n]/dt)/dt ]
.Ve
.PP
The Jacobian code reference is only needed for certain step types, those step types whose names end in \f(CW\*(C`_j\*(C'\fR.
.PP
\fIrequired arguments\fR
.IX Subsection "required arguments"
.PP
\&\f(CW\*(C`ode_solver\*(C'\fR requires two arguments, they are as follows:
.PP
first argument
.IX Subsection "first argument"
.PP
The first argument may be either a code reference or an array reference containing one or two code references. In the single code reference form this represents the differential equation system, constructed as described above. In the array reference form, the first argument must be the differential equation system code reference, but now optionally a code reference for the Jacobian of the system may be supplied as the second item.
.PP
second argument
.IX Subsection "second argument"
.PP
The second argument, \f(CW$t_range\fR, specifies the time values that are used for the calculation. This may be used one of two ways:
.IP "\(bu" 4
An array reference containing numbers specifying start time, finish time, and number of steps.
.IP "\(bu" 4
A scalar number specifying finish time. In this case the start time will be zero and 100 steps will be used.
.PP
\fIoptional argument (the options hash reference)\fR
.IX Subsection "optional argument (the options hash reference)"
.PP
The third argument, \f(CW$opts_hashref\fR, is a hash reference containing other options. They are as follows:
.IP "\(bu" 4
\&\f(CW\*(C`type\*(C'\fR specifies the step type to be used. The default is \f(CW\*(C`rk8pd\*(C'\fR. The available step types can be found using the exportable function \*(L"get_step_types\*(R". Those step types whose name ends in \f(CW\*(C`_j\*(C'\fR require the Jacobian.
.IP "\(bu" 4
\&\f(CW\*(C`h_init\*(C'\fR the initial \*(L"h\*(R" step used by the solver. Defaults to \f(CW\*(C`1e\-6\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`h_max\*(C'\fR the maximum \*(L"h\*(R" step allowed to the adaptive step size solver. Set to zero to use the default value specified the \s-1GSL,\s0 this is the default behavior if unspecified. Note: the module will croak if \f(CW\*(C`h_init\*(C'\fR is set greater than \f(CW\*(C`h_max\*(C'\fR, however if \f(CW\*(C`h_init\*(C'\fR is not specified and the default would violate this relation, \f(CW\*(C`h_init\*(C'\fR will be set to \f(CW\*(C`h_max\*(C'\fR implicitly.
.IP "\(bu" 4
Error scaling options. These all refer to the adaptive step size contoller which is well documented in the \s-1GSL\s0 manual <http://www.gnu.org/software/gsl/manual/html_node/Adaptive-Step_002dsize-Control.html>.
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`epsabs\*(C'\fR and \f(CW\*(C`epsrel\*(C'\fR the allowable error levels (absolute and relative respectively) used in the system. Defaults are \f(CW\*(C`1e\-6\*(C'\fR and \f(CW0.0\fR respectively.
.IP "\(bu" 4
\&\f(CW\*(C`a_y\*(C'\fR and \f(CW\*(C`a_dydt\*(C'\fR set the scaling factors for the function value and the function derivative respectively. While these may be used directly, these can be set using the shorthand ...
.IP "\(bu" 4
\&\f(CW\*(C`scaling\*(C'\fR, a shorthand for setting the above option. The available values may be \f(CW\*(C`y\*(C'\fR meaning \f(CW\*(C`{a_y = 1, a_dydt = 0}\*(C'\fR (which is the default), or \f(CW\*(C`yp\*(C'\fR meaning \f(CW\*(C`{a_y = 0, a_dydt = 1}\*(C'\fR. Note that setting the above scaling factors will override the corresponding field in this shorthand.
.RE
.RS 4
.RE
.PP
\fIreturn\fR
.IX Subsection "return"
.PP
The return is an array reference of array references. Each inner array reference will contain the time and function value of each function in order as above. This format allows easy loading into \s-1PDL\s0 if so desired:
.PP
.Vb 1
\& $pdl = pdl($solution);
.Ve
.PP
of course one may recover one column by simple use of a \f(CW\*(C`map\*(C'\fR:
.PP
.Vb 3
\& @solution_t_vals  = map { $_\->[0] } @$solution;
\& @solution_y1_vals = map { $_\->[1] } @$solution;
\& ...
.Ve
.PP
For a usage example see the \*(L"\s-1SYNOPSIS\*(R"\s0 for a sine function given by \f(CW\*(C`y\*(Aq\*(Aq(t)=\-y(t)\*(C'\fR.
.SH "EXPORTABLE FUNCTIONS"
.IX Header "EXPORTABLE FUNCTIONS"
.SS "get_step_types"
.IX Subsection "get_step_types"
Returns the available step types which may be specified in the \*(L"ode_solver\*(R" function's options hashref. Note that those step types whose name end in \f(CW\*(C`_j\*(C'\fR require the Jacobian.
.SS "get_gsl_version"
.IX Subsection "get_gsl_version"
A simple function taking no arguments and returning the version number of the \s-1GSL\s0 library as specified in \f(CW\*(C`gsl/gsl_version.h\*(C'\fR. This was originally used for dependency checking but now remains simply for the interested user.
.SH "FUTURE GOALS"
.IX Header "FUTURE GOALS"
On systems with \s-1PDL\s0 installed, I would like to include some mechanism which will store the numerical data in a piddle directly, saving the overhead of creating an \s-1SV\s0 for each of the pieces of data generated. I envision this happening as transparently as possible when \s-1PDL\s0 is available. This will probably take some experimentation to get it right.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "PerlGSL" 4
.IX Item "PerlGSL"
.PD 0
.IP "Math::ODE" 4
.IX Item "Math::ODE"
.IP "Math::GSL::ODEIV" 4
.IX Item "Math::GSL::ODEIV"
.IP "\s-1GSL\s0 <http://www.gnu.org/software/gsl/>" 4
.IX Item "GSL <http://www.gnu.org/software/gsl/>"
.IP "\s-1PDL\s0, website <http://pdl.perl.org>" 4
.IX Item "PDL, website <http://pdl.perl.org>"
.PD
.SH "SOURCE REPOSITORY"
.IX Header "SOURCE REPOSITORY"
<http://github.com/jberger/PerlGSL\-DiffEq>
.SH "AUTHOR"
.IX Header "AUTHOR"
Rich Miller, <rich@ski.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2019 by Rich Miller
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.PP
The \s-1GSL\s0 is licensed under the terms of the \s-1GNU\s0 General Public License (\s-1GPL\s0)
